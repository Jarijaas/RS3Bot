// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: world.proto
#ifndef GRPC_world_2eproto__INCLUDED
#define GRPC_world_2eproto__INCLUDED

#include "world.pb.h"

#include <grpc++/impl/codegen/async_stream.h>
#include <grpc++/impl/codegen/async_unary_call.h>
#include <grpc++/impl/codegen/method_handler_impl.h>
#include <grpc++/impl/codegen/proto_utils.h>
#include <grpc++/impl/codegen/rpc_method.h>
#include <grpc++/impl/codegen/service_type.h>
#include <grpc++/impl/codegen/status.h>
#include <grpc++/impl/codegen/stub_options.h>
#include <grpc++/impl/codegen/sync_stream.h>

namespace grpc {
class CompletionQueue;
class Channel;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc

class RS3 final {
 public:
  static constexpr char const* service_full_name() {
    return "RS3";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    virtual ::grpc::Status FindEntities(::grpc::ClientContext* context, const ::EntityRequest& request, ::EntitiesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::EntitiesResponse>> AsyncFindEntities(::grpc::ClientContext* context, const ::EntityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::EntitiesResponse>>(AsyncFindEntitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::EntitiesResponse>> PrepareAsyncFindEntities(::grpc::ClientContext* context, const ::EntityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::EntitiesResponse>>(PrepareAsyncFindEntitiesRaw(context, request, cq));
    }
    virtual ::grpc::Status Interact(::grpc::ClientContext* context, const ::InteractRequest& request, ::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> AsyncInteract(::grpc::ClientContext* context, const ::InteractRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(AsyncInteractRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> PrepareAsyncInteract(::grpc::ClientContext* context, const ::InteractRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(PrepareAsyncInteractRaw(context, request, cq));
    }
    virtual ::grpc::Status MoveTo(::grpc::ClientContext* context, const ::Location& request, ::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> AsyncMoveTo(::grpc::ClientContext* context, const ::Location& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(AsyncMoveToRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> PrepareAsyncMoveTo(::grpc::ClientContext* context, const ::Location& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(PrepareAsyncMoveToRaw(context, request, cq));
    }
    virtual ::grpc::Status GetInventory(::grpc::ClientContext* context, const ::InventoryTypeRequest& request, ::Inventory* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Inventory>> AsyncGetInventory(::grpc::ClientContext* context, const ::InventoryTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Inventory>>(AsyncGetInventoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Inventory>> PrepareAsyncGetInventory(::grpc::ClientContext* context, const ::InventoryTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Inventory>>(PrepareAsyncGetInventoryRaw(context, request, cq));
    }
    virtual ::grpc::Status DoUIAction(::grpc::ClientContext* context, const ::UIAction& request, ::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> AsyncDoUIAction(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(AsyncDoUIActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> PrepareAsyncDoUIAction(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(PrepareAsyncDoUIActionRaw(context, request, cq));
    }
    virtual ::grpc::Status DoItemInterfaceAction(::grpc::ClientContext* context, const ::UIAction& request, ::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> AsyncDoItemInterfaceAction(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(AsyncDoItemInterfaceActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> PrepareAsyncDoItemInterfaceAction(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(PrepareAsyncDoItemInterfaceActionRaw(context, request, cq));
    }
    virtual ::grpc::Status BackpackItemAction(::grpc::ClientContext* context, const ::ItemAction& request, ::Empty* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> AsyncBackpackItemAction(::grpc::ClientContext* context, const ::ItemAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(AsyncBackpackItemActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>> PrepareAsyncBackpackItemAction(::grpc::ClientContext* context, const ::ItemAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Empty>>(PrepareAsyncBackpackItemActionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetProperty(::grpc::ClientContext* context, const ::IdRequest& request, ::PropertyValue* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PropertyValue>> AsyncGetProperty(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PropertyValue>>(AsyncGetPropertyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PropertyValue>> PrepareAsyncGetProperty(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::PropertyValue>>(PrepareAsyncGetPropertyRaw(context, request, cq));
    }
    virtual ::grpc::Status IsUIWidgetVisible(::grpc::ClientContext* context, const ::IdRequest& request, ::BoolResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::BoolResponse>> AsyncIsUIWidgetVisible(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::BoolResponse>>(AsyncIsUIWidgetVisibleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::BoolResponse>> PrepareAsyncIsUIWidgetVisible(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::BoolResponse>>(PrepareAsyncIsUIWidgetVisibleRaw(context, request, cq));
    }
    virtual ::grpc::Status GetControlledPlayer(::grpc::ClientContext* context, const ::Empty& request, ::Entity* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Entity>> AsyncGetControlledPlayer(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Entity>>(AsyncGetControlledPlayerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Entity>> PrepareAsyncGetControlledPlayer(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Entity>>(PrepareAsyncGetControlledPlayerRaw(context, request, cq));
    }
    virtual ::grpc::Status GetWidget(::grpc::ClientContext* context, const ::IdRequest& request, ::Widget* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Widget>> AsyncGetWidget(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Widget>>(AsyncGetWidgetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Widget>> PrepareAsyncGetWidget(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::Widget>>(PrepareAsyncGetWidgetRaw(context, request, cq));
    }
    // Events 
    std::unique_ptr< ::grpc::ClientReaderInterface< ::ChatMessage>> OnChatMessage(::grpc::ClientContext* context, const ::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::ChatMessage>>(OnChatMessageRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ChatMessage>> AsyncOnChatMessage(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ChatMessage>>(AsyncOnChatMessageRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ChatMessage>> PrepareAsyncOnChatMessage(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::ChatMessage>>(PrepareAsyncOnChatMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::CursorActionMessage>> OnCursorAction(::grpc::ClientContext* context, const ::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::CursorActionMessage>>(OnCursorActionRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::CursorActionMessage>> AsyncOnCursorAction(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::CursorActionMessage>>(AsyncOnCursorActionRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::CursorActionMessage>> PrepareAsyncOnCursorAction(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::CursorActionMessage>>(PrepareAsyncOnCursorActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderInterface< ::InterfaceOpenMessage>> OnInterfaceOpen(::grpc::ClientContext* context, const ::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::InterfaceOpenMessage>>(OnInterfaceOpenRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::InterfaceOpenMessage>> AsyncOnInterfaceOpen(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::InterfaceOpenMessage>>(AsyncOnInterfaceOpenRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::InterfaceOpenMessage>> PrepareAsyncOnInterfaceOpen(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::InterfaceOpenMessage>>(PrepareAsyncOnInterfaceOpenRaw(context, request, cq));
    }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::EntitiesResponse>* AsyncFindEntitiesRaw(::grpc::ClientContext* context, const ::EntityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::EntitiesResponse>* PrepareAsyncFindEntitiesRaw(::grpc::ClientContext* context, const ::EntityRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* AsyncInteractRaw(::grpc::ClientContext* context, const ::InteractRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* PrepareAsyncInteractRaw(::grpc::ClientContext* context, const ::InteractRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* AsyncMoveToRaw(::grpc::ClientContext* context, const ::Location& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* PrepareAsyncMoveToRaw(::grpc::ClientContext* context, const ::Location& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Inventory>* AsyncGetInventoryRaw(::grpc::ClientContext* context, const ::InventoryTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Inventory>* PrepareAsyncGetInventoryRaw(::grpc::ClientContext* context, const ::InventoryTypeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* AsyncDoUIActionRaw(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* PrepareAsyncDoUIActionRaw(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* AsyncDoItemInterfaceActionRaw(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* PrepareAsyncDoItemInterfaceActionRaw(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* AsyncBackpackItemActionRaw(::grpc::ClientContext* context, const ::ItemAction& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Empty>* PrepareAsyncBackpackItemActionRaw(::grpc::ClientContext* context, const ::ItemAction& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::PropertyValue>* AsyncGetPropertyRaw(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::PropertyValue>* PrepareAsyncGetPropertyRaw(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::BoolResponse>* AsyncIsUIWidgetVisibleRaw(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::BoolResponse>* PrepareAsyncIsUIWidgetVisibleRaw(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Entity>* AsyncGetControlledPlayerRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Entity>* PrepareAsyncGetControlledPlayerRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Widget>* AsyncGetWidgetRaw(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::Widget>* PrepareAsyncGetWidgetRaw(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::ChatMessage>* OnChatMessageRaw(::grpc::ClientContext* context, const ::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ChatMessage>* AsyncOnChatMessageRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::ChatMessage>* PrepareAsyncOnChatMessageRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::CursorActionMessage>* OnCursorActionRaw(::grpc::ClientContext* context, const ::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::CursorActionMessage>* AsyncOnCursorActionRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::CursorActionMessage>* PrepareAsyncOnCursorActionRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderInterface< ::InterfaceOpenMessage>* OnInterfaceOpenRaw(::grpc::ClientContext* context, const ::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::InterfaceOpenMessage>* AsyncOnInterfaceOpenRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::InterfaceOpenMessage>* PrepareAsyncOnInterfaceOpenRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status FindEntities(::grpc::ClientContext* context, const ::EntityRequest& request, ::EntitiesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::EntitiesResponse>> AsyncFindEntities(::grpc::ClientContext* context, const ::EntityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::EntitiesResponse>>(AsyncFindEntitiesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::EntitiesResponse>> PrepareAsyncFindEntities(::grpc::ClientContext* context, const ::EntityRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::EntitiesResponse>>(PrepareAsyncFindEntitiesRaw(context, request, cq));
    }
    ::grpc::Status Interact(::grpc::ClientContext* context, const ::InteractRequest& request, ::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> AsyncInteract(::grpc::ClientContext* context, const ::InteractRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(AsyncInteractRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> PrepareAsyncInteract(::grpc::ClientContext* context, const ::InteractRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(PrepareAsyncInteractRaw(context, request, cq));
    }
    ::grpc::Status MoveTo(::grpc::ClientContext* context, const ::Location& request, ::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> AsyncMoveTo(::grpc::ClientContext* context, const ::Location& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(AsyncMoveToRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> PrepareAsyncMoveTo(::grpc::ClientContext* context, const ::Location& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(PrepareAsyncMoveToRaw(context, request, cq));
    }
    ::grpc::Status GetInventory(::grpc::ClientContext* context, const ::InventoryTypeRequest& request, ::Inventory* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Inventory>> AsyncGetInventory(::grpc::ClientContext* context, const ::InventoryTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Inventory>>(AsyncGetInventoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Inventory>> PrepareAsyncGetInventory(::grpc::ClientContext* context, const ::InventoryTypeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Inventory>>(PrepareAsyncGetInventoryRaw(context, request, cq));
    }
    ::grpc::Status DoUIAction(::grpc::ClientContext* context, const ::UIAction& request, ::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> AsyncDoUIAction(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(AsyncDoUIActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> PrepareAsyncDoUIAction(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(PrepareAsyncDoUIActionRaw(context, request, cq));
    }
    ::grpc::Status DoItemInterfaceAction(::grpc::ClientContext* context, const ::UIAction& request, ::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> AsyncDoItemInterfaceAction(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(AsyncDoItemInterfaceActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> PrepareAsyncDoItemInterfaceAction(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(PrepareAsyncDoItemInterfaceActionRaw(context, request, cq));
    }
    ::grpc::Status BackpackItemAction(::grpc::ClientContext* context, const ::ItemAction& request, ::Empty* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> AsyncBackpackItemAction(::grpc::ClientContext* context, const ::ItemAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(AsyncBackpackItemActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>> PrepareAsyncBackpackItemAction(::grpc::ClientContext* context, const ::ItemAction& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Empty>>(PrepareAsyncBackpackItemActionRaw(context, request, cq));
    }
    ::grpc::Status GetProperty(::grpc::ClientContext* context, const ::IdRequest& request, ::PropertyValue* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PropertyValue>> AsyncGetProperty(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PropertyValue>>(AsyncGetPropertyRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PropertyValue>> PrepareAsyncGetProperty(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::PropertyValue>>(PrepareAsyncGetPropertyRaw(context, request, cq));
    }
    ::grpc::Status IsUIWidgetVisible(::grpc::ClientContext* context, const ::IdRequest& request, ::BoolResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::BoolResponse>> AsyncIsUIWidgetVisible(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::BoolResponse>>(AsyncIsUIWidgetVisibleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::BoolResponse>> PrepareAsyncIsUIWidgetVisible(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::BoolResponse>>(PrepareAsyncIsUIWidgetVisibleRaw(context, request, cq));
    }
    ::grpc::Status GetControlledPlayer(::grpc::ClientContext* context, const ::Empty& request, ::Entity* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Entity>> AsyncGetControlledPlayer(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Entity>>(AsyncGetControlledPlayerRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Entity>> PrepareAsyncGetControlledPlayer(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Entity>>(PrepareAsyncGetControlledPlayerRaw(context, request, cq));
    }
    ::grpc::Status GetWidget(::grpc::ClientContext* context, const ::IdRequest& request, ::Widget* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Widget>> AsyncGetWidget(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Widget>>(AsyncGetWidgetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Widget>> PrepareAsyncGetWidget(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::Widget>>(PrepareAsyncGetWidgetRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::ChatMessage>> OnChatMessage(::grpc::ClientContext* context, const ::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::ChatMessage>>(OnChatMessageRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ChatMessage>> AsyncOnChatMessage(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ChatMessage>>(AsyncOnChatMessageRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::ChatMessage>> PrepareAsyncOnChatMessage(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::ChatMessage>>(PrepareAsyncOnChatMessageRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::CursorActionMessage>> OnCursorAction(::grpc::ClientContext* context, const ::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::CursorActionMessage>>(OnCursorActionRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::CursorActionMessage>> AsyncOnCursorAction(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::CursorActionMessage>>(AsyncOnCursorActionRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::CursorActionMessage>> PrepareAsyncOnCursorAction(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::CursorActionMessage>>(PrepareAsyncOnCursorActionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReader< ::InterfaceOpenMessage>> OnInterfaceOpen(::grpc::ClientContext* context, const ::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::InterfaceOpenMessage>>(OnInterfaceOpenRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::InterfaceOpenMessage>> AsyncOnInterfaceOpen(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::InterfaceOpenMessage>>(AsyncOnInterfaceOpenRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::InterfaceOpenMessage>> PrepareAsyncOnInterfaceOpen(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::InterfaceOpenMessage>>(PrepareAsyncOnInterfaceOpenRaw(context, request, cq));
    }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    ::grpc::ClientAsyncResponseReader< ::EntitiesResponse>* AsyncFindEntitiesRaw(::grpc::ClientContext* context, const ::EntityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::EntitiesResponse>* PrepareAsyncFindEntitiesRaw(::grpc::ClientContext* context, const ::EntityRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* AsyncInteractRaw(::grpc::ClientContext* context, const ::InteractRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* PrepareAsyncInteractRaw(::grpc::ClientContext* context, const ::InteractRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* AsyncMoveToRaw(::grpc::ClientContext* context, const ::Location& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* PrepareAsyncMoveToRaw(::grpc::ClientContext* context, const ::Location& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Inventory>* AsyncGetInventoryRaw(::grpc::ClientContext* context, const ::InventoryTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Inventory>* PrepareAsyncGetInventoryRaw(::grpc::ClientContext* context, const ::InventoryTypeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* AsyncDoUIActionRaw(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* PrepareAsyncDoUIActionRaw(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* AsyncDoItemInterfaceActionRaw(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* PrepareAsyncDoItemInterfaceActionRaw(::grpc::ClientContext* context, const ::UIAction& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* AsyncBackpackItemActionRaw(::grpc::ClientContext* context, const ::ItemAction& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Empty>* PrepareAsyncBackpackItemActionRaw(::grpc::ClientContext* context, const ::ItemAction& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::PropertyValue>* AsyncGetPropertyRaw(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::PropertyValue>* PrepareAsyncGetPropertyRaw(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::BoolResponse>* AsyncIsUIWidgetVisibleRaw(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::BoolResponse>* PrepareAsyncIsUIWidgetVisibleRaw(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Entity>* AsyncGetControlledPlayerRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Entity>* PrepareAsyncGetControlledPlayerRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Widget>* AsyncGetWidgetRaw(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::Widget>* PrepareAsyncGetWidgetRaw(::grpc::ClientContext* context, const ::IdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::ChatMessage>* OnChatMessageRaw(::grpc::ClientContext* context, const ::Empty& request) override;
    ::grpc::ClientAsyncReader< ::ChatMessage>* AsyncOnChatMessageRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::ChatMessage>* PrepareAsyncOnChatMessageRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::CursorActionMessage>* OnCursorActionRaw(::grpc::ClientContext* context, const ::Empty& request) override;
    ::grpc::ClientAsyncReader< ::CursorActionMessage>* AsyncOnCursorActionRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::CursorActionMessage>* PrepareAsyncOnCursorActionRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReader< ::InterfaceOpenMessage>* OnInterfaceOpenRaw(::grpc::ClientContext* context, const ::Empty& request) override;
    ::grpc::ClientAsyncReader< ::InterfaceOpenMessage>* AsyncOnInterfaceOpenRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::InterfaceOpenMessage>* PrepareAsyncOnInterfaceOpenRaw(::grpc::ClientContext* context, const ::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_FindEntities_;
    const ::grpc::internal::RpcMethod rpcmethod_Interact_;
    const ::grpc::internal::RpcMethod rpcmethod_MoveTo_;
    const ::grpc::internal::RpcMethod rpcmethod_GetInventory_;
    const ::grpc::internal::RpcMethod rpcmethod_DoUIAction_;
    const ::grpc::internal::RpcMethod rpcmethod_DoItemInterfaceAction_;
    const ::grpc::internal::RpcMethod rpcmethod_BackpackItemAction_;
    const ::grpc::internal::RpcMethod rpcmethod_GetProperty_;
    const ::grpc::internal::RpcMethod rpcmethod_IsUIWidgetVisible_;
    const ::grpc::internal::RpcMethod rpcmethod_GetControlledPlayer_;
    const ::grpc::internal::RpcMethod rpcmethod_GetWidget_;
    const ::grpc::internal::RpcMethod rpcmethod_OnChatMessage_;
    const ::grpc::internal::RpcMethod rpcmethod_OnCursorAction_;
    const ::grpc::internal::RpcMethod rpcmethod_OnInterfaceOpen_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status FindEntities(::grpc::ServerContext* context, const ::EntityRequest* request, ::EntitiesResponse* response);
    virtual ::grpc::Status Interact(::grpc::ServerContext* context, const ::InteractRequest* request, ::Empty* response);
    virtual ::grpc::Status MoveTo(::grpc::ServerContext* context, const ::Location* request, ::Empty* response);
    virtual ::grpc::Status GetInventory(::grpc::ServerContext* context, const ::InventoryTypeRequest* request, ::Inventory* response);
    virtual ::grpc::Status DoUIAction(::grpc::ServerContext* context, const ::UIAction* request, ::Empty* response);
    virtual ::grpc::Status DoItemInterfaceAction(::grpc::ServerContext* context, const ::UIAction* request, ::Empty* response);
    virtual ::grpc::Status BackpackItemAction(::grpc::ServerContext* context, const ::ItemAction* request, ::Empty* response);
    virtual ::grpc::Status GetProperty(::grpc::ServerContext* context, const ::IdRequest* request, ::PropertyValue* response);
    virtual ::grpc::Status IsUIWidgetVisible(::grpc::ServerContext* context, const ::IdRequest* request, ::BoolResponse* response);
    virtual ::grpc::Status GetControlledPlayer(::grpc::ServerContext* context, const ::Empty* request, ::Entity* response);
    virtual ::grpc::Status GetWidget(::grpc::ServerContext* context, const ::IdRequest* request, ::Widget* response);
    // Events 
    virtual ::grpc::Status OnChatMessage(::grpc::ServerContext* context, const ::Empty* request, ::grpc::ServerWriter< ::ChatMessage>* writer);
    virtual ::grpc::Status OnCursorAction(::grpc::ServerContext* context, const ::Empty* request, ::grpc::ServerWriter< ::CursorActionMessage>* writer);
    virtual ::grpc::Status OnInterfaceOpen(::grpc::ServerContext* context, const ::Empty* request, ::grpc::ServerWriter< ::InterfaceOpenMessage>* writer);
  };
  template <class BaseClass>
  class WithAsyncMethod_FindEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_FindEntities() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_FindEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindEntities(::grpc::ServerContext* context, const ::EntityRequest* request, ::EntitiesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestFindEntities(::grpc::ServerContext* context, ::EntityRequest* request, ::grpc::ServerAsyncResponseWriter< ::EntitiesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Interact : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_Interact() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Interact() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Interact(::grpc::ServerContext* context, const ::InteractRequest* request, ::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestInteract(::grpc::ServerContext* context, ::InteractRequest* request, ::grpc::ServerAsyncResponseWriter< ::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_MoveTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_MoveTo() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_MoveTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTo(::grpc::ServerContext* context, const ::Location* request, ::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestMoveTo(::grpc::ServerContext* context, ::Location* request, ::grpc::ServerAsyncResponseWriter< ::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetInventory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetInventory() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetInventory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInventory(::grpc::ServerContext* context, const ::InventoryTypeRequest* request, ::Inventory* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetInventory(::grpc::ServerContext* context, ::InventoryTypeRequest* request, ::grpc::ServerAsyncResponseWriter< ::Inventory>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DoUIAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DoUIAction() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_DoUIAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DoUIAction(::grpc::ServerContext* context, const ::UIAction* request, ::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDoUIAction(::grpc::ServerContext* context, ::UIAction* request, ::grpc::ServerAsyncResponseWriter< ::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DoItemInterfaceAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_DoItemInterfaceAction() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_DoItemInterfaceAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DoItemInterfaceAction(::grpc::ServerContext* context, const ::UIAction* request, ::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDoItemInterfaceAction(::grpc::ServerContext* context, ::UIAction* request, ::grpc::ServerAsyncResponseWriter< ::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_BackpackItemAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_BackpackItemAction() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_BackpackItemAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BackpackItemAction(::grpc::ServerContext* context, const ::ItemAction* request, ::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBackpackItemAction(::grpc::ServerContext* context, ::ItemAction* request, ::grpc::ServerAsyncResponseWriter< ::Empty>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetProperty() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProperty(::grpc::ServerContext* context, const ::IdRequest* request, ::PropertyValue* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetProperty(::grpc::ServerContext* context, ::IdRequest* request, ::grpc::ServerAsyncResponseWriter< ::PropertyValue>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsUIWidgetVisible : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_IsUIWidgetVisible() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_IsUIWidgetVisible() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsUIWidgetVisible(::grpc::ServerContext* context, const ::IdRequest* request, ::BoolResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsUIWidgetVisible(::grpc::ServerContext* context, ::IdRequest* request, ::grpc::ServerAsyncResponseWriter< ::BoolResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetControlledPlayer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetControlledPlayer() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetControlledPlayer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetControlledPlayer(::grpc::ServerContext* context, const ::Empty* request, ::Entity* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetControlledPlayer(::grpc::ServerContext* context, ::Empty* request, ::grpc::ServerAsyncResponseWriter< ::Entity>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetWidget : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_GetWidget() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetWidget() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWidget(::grpc::ServerContext* context, const ::IdRequest* request, ::Widget* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetWidget(::grpc::ServerContext* context, ::IdRequest* request, ::grpc::ServerAsyncResponseWriter< ::Widget>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OnChatMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_OnChatMessage() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_OnChatMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnChatMessage(::grpc::ServerContext* context, const ::Empty* request, ::grpc::ServerWriter< ::ChatMessage>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOnChatMessage(::grpc::ServerContext* context, ::Empty* request, ::grpc::ServerAsyncWriter< ::ChatMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(11, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OnCursorAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_OnCursorAction() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_OnCursorAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnCursorAction(::grpc::ServerContext* context, const ::Empty* request, ::grpc::ServerWriter< ::CursorActionMessage>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOnCursorAction(::grpc::ServerContext* context, ::Empty* request, ::grpc::ServerAsyncWriter< ::CursorActionMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(12, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_OnInterfaceOpen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithAsyncMethod_OnInterfaceOpen() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_OnInterfaceOpen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnInterfaceOpen(::grpc::ServerContext* context, const ::Empty* request, ::grpc::ServerWriter< ::InterfaceOpenMessage>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOnInterfaceOpen(::grpc::ServerContext* context, ::Empty* request, ::grpc::ServerAsyncWriter< ::InterfaceOpenMessage>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(13, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_FindEntities<WithAsyncMethod_Interact<WithAsyncMethod_MoveTo<WithAsyncMethod_GetInventory<WithAsyncMethod_DoUIAction<WithAsyncMethod_DoItemInterfaceAction<WithAsyncMethod_BackpackItemAction<WithAsyncMethod_GetProperty<WithAsyncMethod_IsUIWidgetVisible<WithAsyncMethod_GetControlledPlayer<WithAsyncMethod_GetWidget<WithAsyncMethod_OnChatMessage<WithAsyncMethod_OnCursorAction<WithAsyncMethod_OnInterfaceOpen<Service > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithGenericMethod_FindEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_FindEntities() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_FindEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status FindEntities(::grpc::ServerContext* context, const ::EntityRequest* request, ::EntitiesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Interact : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_Interact() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Interact() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Interact(::grpc::ServerContext* context, const ::InteractRequest* request, ::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_MoveTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_MoveTo() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_MoveTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status MoveTo(::grpc::ServerContext* context, const ::Location* request, ::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetInventory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetInventory() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetInventory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetInventory(::grpc::ServerContext* context, const ::InventoryTypeRequest* request, ::Inventory* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DoUIAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DoUIAction() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_DoUIAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DoUIAction(::grpc::ServerContext* context, const ::UIAction* request, ::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DoItemInterfaceAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_DoItemInterfaceAction() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_DoItemInterfaceAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DoItemInterfaceAction(::grpc::ServerContext* context, const ::UIAction* request, ::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_BackpackItemAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_BackpackItemAction() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_BackpackItemAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status BackpackItemAction(::grpc::ServerContext* context, const ::ItemAction* request, ::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetProperty() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetProperty(::grpc::ServerContext* context, const ::IdRequest* request, ::PropertyValue* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsUIWidgetVisible : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_IsUIWidgetVisible() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_IsUIWidgetVisible() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsUIWidgetVisible(::grpc::ServerContext* context, const ::IdRequest* request, ::BoolResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetControlledPlayer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetControlledPlayer() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetControlledPlayer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetControlledPlayer(::grpc::ServerContext* context, const ::Empty* request, ::Entity* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetWidget : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_GetWidget() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetWidget() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetWidget(::grpc::ServerContext* context, const ::IdRequest* request, ::Widget* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OnChatMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_OnChatMessage() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_OnChatMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnChatMessage(::grpc::ServerContext* context, const ::Empty* request, ::grpc::ServerWriter< ::ChatMessage>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OnCursorAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_OnCursorAction() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_OnCursorAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnCursorAction(::grpc::ServerContext* context, const ::Empty* request, ::grpc::ServerWriter< ::CursorActionMessage>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_OnInterfaceOpen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithGenericMethod_OnInterfaceOpen() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_OnInterfaceOpen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status OnInterfaceOpen(::grpc::ServerContext* context, const ::Empty* request, ::grpc::ServerWriter< ::InterfaceOpenMessage>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_FindEntities : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_FindEntities() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::EntityRequest, ::EntitiesResponse>(std::bind(&WithStreamedUnaryMethod_FindEntities<BaseClass>::StreamedFindEntities, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_FindEntities() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status FindEntities(::grpc::ServerContext* context, const ::EntityRequest* request, ::EntitiesResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedFindEntities(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::EntityRequest,::EntitiesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Interact : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_Interact() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler< ::InteractRequest, ::Empty>(std::bind(&WithStreamedUnaryMethod_Interact<BaseClass>::StreamedInteract, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Interact() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Interact(::grpc::ServerContext* context, const ::InteractRequest* request, ::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedInteract(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InteractRequest,::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_MoveTo : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_MoveTo() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::Location, ::Empty>(std::bind(&WithStreamedUnaryMethod_MoveTo<BaseClass>::StreamedMoveTo, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_MoveTo() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status MoveTo(::grpc::ServerContext* context, const ::Location* request, ::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedMoveTo(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Location,::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetInventory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetInventory() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::InventoryTypeRequest, ::Inventory>(std::bind(&WithStreamedUnaryMethod_GetInventory<BaseClass>::StreamedGetInventory, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetInventory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetInventory(::grpc::ServerContext* context, const ::InventoryTypeRequest* request, ::Inventory* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetInventory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::InventoryTypeRequest,::Inventory>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DoUIAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DoUIAction() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::UIAction, ::Empty>(std::bind(&WithStreamedUnaryMethod_DoUIAction<BaseClass>::StreamedDoUIAction, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DoUIAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DoUIAction(::grpc::ServerContext* context, const ::UIAction* request, ::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDoUIAction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UIAction,::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DoItemInterfaceAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_DoItemInterfaceAction() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::UIAction, ::Empty>(std::bind(&WithStreamedUnaryMethod_DoItemInterfaceAction<BaseClass>::StreamedDoItemInterfaceAction, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_DoItemInterfaceAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DoItemInterfaceAction(::grpc::ServerContext* context, const ::UIAction* request, ::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDoItemInterfaceAction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::UIAction,::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_BackpackItemAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_BackpackItemAction() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::ItemAction, ::Empty>(std::bind(&WithStreamedUnaryMethod_BackpackItemAction<BaseClass>::StreamedBackpackItemAction, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_BackpackItemAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status BackpackItemAction(::grpc::ServerContext* context, const ::ItemAction* request, ::Empty* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBackpackItemAction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::ItemAction,::Empty>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetProperty : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetProperty() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::IdRequest, ::PropertyValue>(std::bind(&WithStreamedUnaryMethod_GetProperty<BaseClass>::StreamedGetProperty, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetProperty() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetProperty(::grpc::ServerContext* context, const ::IdRequest* request, ::PropertyValue* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetProperty(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IdRequest,::PropertyValue>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsUIWidgetVisible : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_IsUIWidgetVisible() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::IdRequest, ::BoolResponse>(std::bind(&WithStreamedUnaryMethod_IsUIWidgetVisible<BaseClass>::StreamedIsUIWidgetVisible, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_IsUIWidgetVisible() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsUIWidgetVisible(::grpc::ServerContext* context, const ::IdRequest* request, ::BoolResponse* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsUIWidgetVisible(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IdRequest,::BoolResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetControlledPlayer : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetControlledPlayer() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler< ::Empty, ::Entity>(std::bind(&WithStreamedUnaryMethod_GetControlledPlayer<BaseClass>::StreamedGetControlledPlayer, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetControlledPlayer() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetControlledPlayer(::grpc::ServerContext* context, const ::Empty* request, ::Entity* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetControlledPlayer(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::Empty,::Entity>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetWidget : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithStreamedUnaryMethod_GetWidget() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::IdRequest, ::Widget>(std::bind(&WithStreamedUnaryMethod_GetWidget<BaseClass>::StreamedGetWidget, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetWidget() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetWidget(::grpc::ServerContext* context, const ::IdRequest* request, ::Widget* response) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetWidget(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::IdRequest,::Widget>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_FindEntities<WithStreamedUnaryMethod_Interact<WithStreamedUnaryMethod_MoveTo<WithStreamedUnaryMethod_GetInventory<WithStreamedUnaryMethod_DoUIAction<WithStreamedUnaryMethod_DoItemInterfaceAction<WithStreamedUnaryMethod_BackpackItemAction<WithStreamedUnaryMethod_GetProperty<WithStreamedUnaryMethod_IsUIWidgetVisible<WithStreamedUnaryMethod_GetControlledPlayer<WithStreamedUnaryMethod_GetWidget<Service > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_OnChatMessage : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_OnChatMessage() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::SplitServerStreamingHandler< ::Empty, ::ChatMessage>(std::bind(&WithSplitStreamingMethod_OnChatMessage<BaseClass>::StreamedOnChatMessage, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_OnChatMessage() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OnChatMessage(::grpc::ServerContext* context, const ::Empty* request, ::grpc::ServerWriter< ::ChatMessage>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedOnChatMessage(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::Empty,::ChatMessage>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_OnCursorAction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_OnCursorAction() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::SplitServerStreamingHandler< ::Empty, ::CursorActionMessage>(std::bind(&WithSplitStreamingMethod_OnCursorAction<BaseClass>::StreamedOnCursorAction, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_OnCursorAction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OnCursorAction(::grpc::ServerContext* context, const ::Empty* request, ::grpc::ServerWriter< ::CursorActionMessage>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedOnCursorAction(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::Empty,::CursorActionMessage>* server_split_streamer) = 0;
  };
  template <class BaseClass>
  class WithSplitStreamingMethod_OnInterfaceOpen : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service *service) {}
   public:
    WithSplitStreamingMethod_OnInterfaceOpen() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::SplitServerStreamingHandler< ::Empty, ::InterfaceOpenMessage>(std::bind(&WithSplitStreamingMethod_OnInterfaceOpen<BaseClass>::StreamedOnInterfaceOpen, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithSplitStreamingMethod_OnInterfaceOpen() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status OnInterfaceOpen(::grpc::ServerContext* context, const ::Empty* request, ::grpc::ServerWriter< ::InterfaceOpenMessage>* writer) final override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedOnInterfaceOpen(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::Empty,::InterfaceOpenMessage>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_OnChatMessage<WithSplitStreamingMethod_OnCursorAction<WithSplitStreamingMethod_OnInterfaceOpen<Service > > > SplitStreamedService;
  typedef WithStreamedUnaryMethod_FindEntities<WithStreamedUnaryMethod_Interact<WithStreamedUnaryMethod_MoveTo<WithStreamedUnaryMethod_GetInventory<WithStreamedUnaryMethod_DoUIAction<WithStreamedUnaryMethod_DoItemInterfaceAction<WithStreamedUnaryMethod_BackpackItemAction<WithStreamedUnaryMethod_GetProperty<WithStreamedUnaryMethod_IsUIWidgetVisible<WithStreamedUnaryMethod_GetControlledPlayer<WithStreamedUnaryMethod_GetWidget<WithSplitStreamingMethod_OnChatMessage<WithSplitStreamingMethod_OnCursorAction<WithSplitStreamingMethod_OnInterfaceOpen<Service > > > > > > > > > > > > > > StreamedService;
};


#endif  // GRPC_world_2eproto__INCLUDED
